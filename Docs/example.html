# HTML Example with CDN
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TunRTC Simple Example</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; padding: 20px; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #333; margin-bottom: 20px; }
        .controls { margin: 20px 0; }
        button { padding: 10px 20px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input { padding: 10px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 200px; }
        .video-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        video { width: 100%; border-radius: 8px; background: #000; }
        .video-wrapper { position: relative; }
        .video-label { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        #messages { height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin: 10px 0; border-radius: 4px; background: #f9f9f9; }
        .message { margin: 5px 0; padding: 5px; }
        .message .username { font-weight: bold; color: #007bff; }
        #status { padding: 10px; margin: 10px 0; border-radius: 4px; background: #e9ecef; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¥ TunRTC Video Call Demo</h1>
        
        <div id="status">Status: Not connected</div>

        <div class="controls">
            <h3>Login</h3>
            <input type="email" id="email" placeholder="Email" value="demo@tunrtc.com">
            <input type="password" id="password" placeholder="Password" value="demo123">
            <button id="btn-login">Login</button>
        </div>

        <div class="controls">
            <h3>Session</h3>
            <input type="text" id="session-name" placeholder="Session Name" value="My Call">
            <button id="btn-create" disabled>Create Session</button>
            <br>
            <input type="text" id="session-id" placeholder="Session ID">
            <button id="btn-join" disabled>Join Session</button>
            <button id="btn-leave" disabled>Leave Session</button>
        </div>

        <div class="controls">
            <h3>Media Controls</h3>
            <button id="btn-mute" disabled>ðŸŽ¤ Mute</button>
            <button id="btn-video" disabled>ðŸ“¹ Disable Video</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="local-video" autoplay muted></video>
                <div class="video-label">You (Local)</div>
            </div>
            <div id="remote-videos"></div>
        </div>

        <div class="controls">
            <h3>Chat</h3>
            <div id="messages"></div>
            <input type="text" id="message-input" placeholder="Type a message...">
            <button id="btn-send" disabled>Send</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@8.0.0/dist/browser/signalr.min.js"></script>
    <script>
        // TunRTC Client Code (embedded for simplicity)
        class TunRTCClient {
            constructor(config) {
                this.apiUrl = config.apiUrl || 'https://localhost:7000/api';
                this.hubUrl = config.hubUrl || 'https://localhost:7000/hubs/signaling';
                this.token = null;
                this.connection = null;
                this.localStream = null;
                this.peerConnections = new Map();
                this.iceServers = [];
                this.sessionId = null;
                
                this.onLocalStream = null;
                this.onRemoteStream = null;
                this.onParticipantJoined = null;
                this.onParticipantLeft = null;
                this.onMessage = null;
                this.onError = null;
                this.onStatusChanged = null;
            }

            async login(email, password) {
                const response = await fetch(`${this.apiUrl}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                const data = await response.json();
                this.token = data.token;
                return data;
            }

            async createSession(name, maxParticipants = 10) {
                const response = await fetch(`${this.apiUrl}/session/create`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.token}`
                    },
                    body: JSON.stringify({ name, maxParticipants, type: 1 })
                });
                return await response.json();
            }

            async joinSession(sessionId, audioEnabled, videoEnabled) {
                this.sessionId = sessionId;
                await this.getIceServers();
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    audio: audioEnabled,
                    video: videoEnabled
                });
                if (this.onLocalStream) this.onLocalStream(this.localStream);
                await this._connectToHub();
                await this.connection.invoke('JoinSession', sessionId);
            }

            async leaveSession() {
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }
                this.peerConnections.forEach(pc => pc.close());
                this.peerConnections.clear();
                if (this.connection) {
                    await this.connection.invoke('LeaveSession', this.sessionId);
                }
            }

            async getIceServers() {
                const response = await fetch(`${this.apiUrl}/iceservers`, {
                    headers: { 'Authorization': `Bearer ${this.token}` }
                });
                const config = await response.json();
                this.iceServers = config.iceServers;
            }

            async _connectToHub() {
                this.connection = new signalR.HubConnectionBuilder()
                    .withUrl(this.hubUrl, { accessTokenFactory: () => this.token })
                    .withAutomaticReconnect()
                    .build();

                this.connection.on('ParticipantJoined', async (data) => {
                    if (this.onParticipantJoined) this.onParticipantJoined(data);
                    await this._createPeerConnection(data.connectionId);
                    await this._createOffer(data.connectionId);
                });

                this.connection.on('ParticipantLeft', (data) => {
                    if (this.onParticipantLeft) this.onParticipantLeft(data);
                    const pc = this.peerConnections.get(data.connectionId);
                    if (pc) {
                        pc.close();
                        this.peerConnections.delete(data.connectionId);
                    }
                });

                this.connection.on('ReceiveOffer', async (data) => {
                    await this._handleOffer(data.fromConnectionId, data.offer);
                });

                this.connection.on('ReceiveAnswer', async (data) => {
                    await this._handleAnswer(data.fromConnectionId, data.answer);
                });

                this.connection.on('ReceiveIceCandidate', async (data) => {
                    await this._handleIceCandidate(data.fromConnectionId, data.candidate);
                });

                this.connection.on('ReceiveMessage', (data) => {
                    if (this.onMessage) this.onMessage(data);
                });

                await this.connection.start();
                if (this.onStatusChanged) this.onStatusChanged('Connected');
            }

            async _createPeerConnection(connectionId) {
                const pc = new RTCPeerConnection({ iceServers: this.iceServers });
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => pc.addTrack(track, this.localStream));
                }
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.connection.invoke('SendIceCandidate', connectionId, event.candidate);
                    }
                };
                pc.ontrack = (event) => {
                    if (this.onRemoteStream) {
                        this.onRemoteStream({ connectionId, stream: event.streams[0] });
                    }
                };
                this.peerConnections.set(connectionId, pc);
                return pc;
            }

            async _createOffer(connectionId) {
                const pc = this.peerConnections.get(connectionId);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await this.connection.invoke('SendOffer', connectionId, offer);
            }

            async _handleOffer(connectionId, offer) {
                let pc = this.peerConnections.get(connectionId);
                if (!pc) pc = await this._createPeerConnection(connectionId);
                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await this.connection.invoke('SendAnswer', connectionId, answer);
            }

            async _handleAnswer(connectionId, answer) {
                const pc = this.peerConnections.get(connectionId);
                if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));
            }

            async _handleIceCandidate(connectionId, candidate) {
                const pc = this.peerConnections.get(connectionId);
                if (pc) await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }

            async updateStatus(isMuted, isVideoEnabled) {
                if (this.localStream) {
                    this.localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
                    this.localStream.getVideoTracks().forEach(t => t.enabled = isVideoEnabled);
                }
                await this.connection.invoke('UpdateStatus', this.sessionId, isMuted, isVideoEnabled);
            }

            async sendMessage(message) {
                await this.connection.invoke('SendMessage', this.sessionId, message);
            }
        }

        // Application Code
        const client = new TunRTCClient({
            apiUrl: 'https://localhost:7000/api',
            hubUrl: 'https://localhost:7000/hubs/signaling'
        });

        let isMuted = false;
        let isVideoEnabled = true;

        // Event handlers
        client.onLocalStream = (stream) => {
            document.getElementById('local-video').srcObject = stream;
        };

        client.onRemoteStream = (data) => {
            let video = document.getElementById(`remote-${data.connectionId}`);
            if (!video) {
                const wrapper = document.createElement('div');
                wrapper.className = 'video-wrapper';
                video = document.createElement('video');
                video.id = `remote-${data.connectionId}`;
                video.autoplay = true;
                const label = document.createElement('div');
                label.className = 'video-label';
                label.textContent = 'Remote User';
                wrapper.appendChild(video);
                wrapper.appendChild(label);
                document.getElementById('remote-videos').appendChild(wrapper);
            }
            video.srcObject = data.stream;
        };

        client.onParticipantLeft = (data) => {
            const video = document.getElementById(`remote-${data.connectionId}`);
            if (video) video.parentElement.remove();
        };

        client.onMessage = (data) => {
            const div = document.createElement('div');
            div.className = 'message';
            div.innerHTML = `<span class="username">${data.username}:</span> ${data.message}`;
            document.getElementById('messages').appendChild(div);
            document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
        };

        client.onStatusChanged = (status) => {
            document.getElementById('status').textContent = `Status: ${status}`;
        };

        // Button handlers
        document.getElementById('btn-login').onclick = async () => {
            try {
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                await client.login(email, password);
                alert('Logged in successfully!');
                document.getElementById('btn-create').disabled = false;
                document.getElementById('btn-join').disabled = false;
                document.getElementById('status').textContent = 'Status: Logged in';
            } catch (error) {
                alert('Login failed: ' + error.message);
            }
        };

        document.getElementById('btn-create').onclick = async () => {
            try {
                const name = document.getElementById('session-name').value;
                const session = await client.createSession(name);
                document.getElementById('session-id').value = session.sessionId;
                alert('Session created: ' + session.sessionId);
            } catch (error) {
                alert('Create failed: ' + error.message);
            }
        };

        document.getElementById('btn-join').onclick = async () => {
            try {
                const sessionId = document.getElementById('session-id').value;
                await client.joinSession(sessionId, true, true);
                document.getElementById('btn-leave').disabled = false;
                document.getElementById('btn-mute').disabled = false;
                document.getElementById('btn-video').disabled = false;
                document.getElementById('btn-send').disabled = false;
            } catch (error) {
                alert('Join failed: ' + error.message);
            }
        };

        document.getElementById('btn-leave').onclick = async () => {
            await client.leaveSession();
            document.getElementById('remote-videos').innerHTML = '';
            document.getElementById('btn-leave').disabled = true;
            document.getElementById('btn-mute').disabled = true;
            document.getElementById('btn-video').disabled = true;
            document.getElementById('btn-send').disabled = true;
        };

        document.getElementById('btn-mute').onclick = async () => {
            isMuted = !isMuted;
            await client.updateStatus(isMuted, isVideoEnabled);
            document.getElementById('btn-mute').textContent = isMuted ? 'ðŸ”‡ Unmute' : 'ðŸŽ¤ Mute';
        };

        document.getElementById('btn-video').onclick = async () => {
            isVideoEnabled = !isVideoEnabled;
            await client.updateStatus(isMuted, isVideoEnabled);
            document.getElementById('btn-video').textContent = isVideoEnabled ? 'ðŸ“¹ Disable Video' : 'ðŸ“¹ Enable Video';
        };

        document.getElementById('btn-send').onclick = async () => {
            const input = document.getElementById('message-input');
            if (input.value) {
                await client.sendMessage(input.value);
                input.value = '';
            }
        };

        document.getElementById('message-input').onkeypress = (e) => {
            if (e.key === 'Enter') document.getElementById('btn-send').click();
        };
    </script>
</body>
</html>
